namespace Domain.SharedKernel.Base;

public class SequentialGuid 
{
    //public static Guid New()
    //{
    //    //https://github.com/dotnet/efcore/blob/main/src/EFCore/ValueGeneration/SequentialGuidValueGenerator.cs
    //    //https://davecallan.com/generating-sequential-guids-which-sort-sql-server-in-net/
    //    // source sequential guid from .net: https://github.com/dotnet/efcore/blob/main/src/EFCore/ValueGeneration/SequentialGuidValueGenerator.cs

    //    //using mac address for sequential guid will not create if you use fake address: https://devblogs.microsoft.com/oldnewthing/20191120-00/?p=103118
    //    //using mac address for sequential guid might result in fragmentation and performance issue if you have many virtual machine
    //    // that contain your application (multi instances) access the same db server.

    //    /*
    //     * https://dev.to/connerphillis/sequential-guids-in-entity-framework-core-might-not-be-sequential-3408
    //     * setting a column to use a GUID as a key with DatabaseGeneratedOption.Identity does not mean that it 
    //     *  will be generated by the database. Instead, EF Core generates the sequential GUID itself, and then 
    //     *  inserts it into the database
    //     */
    //    //https://learn.microsoft.com/en-us/ef/core/modeling/generated-properties?tabs=fluent-api
    //    /*
    //     * For example, on SQL Server, when a GUID property is configured as a primary key, 
    //     *  the provider automatically performs value generation client-side, using an algorithm 
    //     *  to generate optimal sequential GUID values.
    //     */
    //    // From that links, The sequential Guid using SequentialGuidValueGenerator() as a default and generate
    //    // at client side, not database side. So you don't do anything because SequentialGuidValueGenerator() is
    //    // configured as a default of behaviour. You can test it when calling Attach or Add method from DbContext.
    //    //var id = RT.Comb.Provider.Sql.Create();
    //    var id = new SequentialGuidValueGenerator().Next(null);
    //    return id;
    //}
    
    public static int CompareTo(Guid left, Guid right)
    {
        //https://github.com/dotnet/efcore/blob/main/src/EFCore/ValueGeneration/SequentialGuidValueGenerator.cs
        /*
         * from document above, we can see that .Net implements Sequential Guid from Guid.NewGuid() and then rewrite
         * data from 8 to 15 of indexes. 
         * Please check AnalyzeStructureOfSequentialGuid.xlsx to visualize the array of Guid
         */

        Span<byte> leftGuids = stackalloc byte[16];
        Span<byte> rightGuids = stackalloc byte[16];
        left.TryWriteBytes(leftGuids);
        right.TryWriteBytes(rightGuids);

        //Asymptotic analysis: Best case: Compare Guid with O(log n), if Guid is not equal
        //Compare Sequential Guid implemented from EntityFramework Core
        for (int i = 8; i < 16; i ++)
        {
            if (leftGuids[i] > rightGuids[i])
                return 1;
            else if (leftGuids[i] < rightGuids[i])
                return -1;
        }

        //Asymptotic analysis: Worst and Average case: Compare Guid with O(n), if Guid is just Guid.NewGuid()
        //if Sequential Guid from 8 to 15 indexes are equal, we compare the rest of array Guid
        for (int i = 0; i < 8; i++)
        {
            if (leftGuids[i] > rightGuids[i])
                return 1;
            else if (leftGuids[i] < rightGuids[i])
                return -1;
        }

        return 0;
    }
}